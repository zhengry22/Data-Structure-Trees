# Game解题报告
> 作者：计26 郑睿阳 2022010849

## 数据结构 & 算法
* 这道题目是一个典型的计算最短路的问题。本题采取的算法是堆优化的 Dijkstra 算法。使用到了自己编写的堆类。
* 本题基本上是一个传统意义上的模板题，但在一些细节方面的实现上有需要注意的地方：
    * 首先是关于堆的存储：不需要实现一开始的建堆算法（因为是从起始点开始进行搜索，一个一个将搜索到的点放入堆中的）。由于涉及到堆的动态操作，因此在本题中实现堆类的时候使用一个预先开好的数组作为容器，避免了大量 `new` 和 `delete` 操作带来的时间开销。
    * 与普通的 Dijkstra 算法相比，从某个节点到下一个节点的时间实际上并非取决于边的权值，而是“点的权值”。这一点对于理解题意很重要。
    * 算法当中要求实现对于最短路径的记录，也是本题区别于传统最短路问题的一个难点。具体实现方法是在每个节点内部维护变量 `path_number`，即从起点到达该节点一共有多少条最短路。然后进行 PFS 的时候，在传统的 Dijkstra 算法之余还需要实现：
        * 如果更新节点信息的时候能够将当前权值缩小，这代表找到了新的最短路，将 `path_number` 置为一；
        * 如果更新节点信息时找到的新的权值与节点当前权值相同则将 `path_number` 加一；
        * 否则不进行操作。
* 堆优化的过程当中需要通过指针维护访问节点和堆中节点的关系。具体表现为如果节点未在堆中就插入；已在堆中就改变权值并且上滤（因为维护的是一个小顶堆，若改变权值一定是变小，所以一定是上滤）。做了永久标记的节点将会被从堆中删除。

## 复杂度分析
* 记边，节点的个数分别为$m$, $n$, 相比于普通 Dijkstra $O(n^2+m)$ 的复杂度而言，堆优化可以将复杂度减小到 $O((n+m)logn)$。同时，需要维护空间复杂度为 $O(n)$ 的堆以及 $O(n+m)$ 的邻接表来表示图。