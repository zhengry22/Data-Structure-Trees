#Filename解题报告
> 作者：计26 郑睿阳 2022010849

## 算法
* 事实上，这道题目乍一看，是一道非常经典的 $LCS$ 算法问题。$LCS$ 算法的典型实现方法是动态规划：设长 $a$, $b$ 的序列的的 $LCS$ 长度是 $f(a,b)$, 考察两个序列的最后一个字母是否相同：
$$f(a,b) = \left\{\begin{matrix}
f(a-1, b-1) + 1, 最后一个字母相同\\
max\left\{f(a-1, b), f(a, b-1)\right\}, 最后一个字母不同
\end{matrix}\right.
$$
其递归基是 $a = 0$ 或 $b = 0$ 的情况。这时，$f(a,b) = 0$ 。根据这道题的数据规模，我们知道它并不能通过传统的递归填表法进行实现，这是因为题目中给的串的两个长度 $n$, $m$ 的乘积已经达到了$10^{11}$的数量级，超过了我们能够申请的数组规模的最大范围。

## 数据结构
* 这时，我们自然想到了使用递推做法。对于 $LCS$ 问题，使用递推做法只需要开两个规模为 $n$ 或 $m$ 的数组。这是因为，如果我们假设 $f(a,b)$ 的结果被填在一张规模为 $nm$ 的表当中，横坐标为 $a$, 纵坐标为 $b$, 那么其结果应当只和它上面的一行中的元素，或是与它同一行，在它左侧的元素相关（这一点通过上面的状态转移方程很容易就能看出来）。所以，我们在每次计算 $f(a, b)$ 时只需留下第 $a-1$ 行和第 $a$ 行在该元素前面的元素。整个过程当中只需要开两个规模为 $n$ 的数组，完全可行。同时，根据这个填表算法从左到右，从上到下的填表顺序，我们也不难发现，它的时间复杂度应当是 $O(mn)$ 的。

## 这就完了吗？
* 且慢... 通过朴素的 $LCS$ 算法，我们在OJ上的提交超时了！这是为什么呢？通过简单的反思，我们意识到：$O(mn)$ 的算法在这道题当中是无法接受的——通常来说，$1s$ 的题目通常要将算法的复杂度数值控制在 $10^9$ 的数量级以内，而简单粗暴的 $LCS$ 算法已经达到了 $10^{11}$ 的量级了...我们还需要优化，可是怎么优化呢？$LCS$ 的复杂度似乎已经没法优化了啊！
* 这时，我们注意到了这道题目有一个特殊的要求：如果需要超过 $k$ 次操作就输出 $-1$ 。如果需要进行 $k$ 次操作，则 $LCS$ 长为 $n+m-2k$ 。既然在这样的条件下，是否有必要进行所有的递推？
* 很容易想到的一点是，如果两个串的长度差超过 $k$ ,则一定需要超过 $k$ 次操作。在进行递推的时候，我们相应的也只需要在递推的时候考虑这种情况。换句话说，在状态转移方程当中“最后一个字母不同”的情况当中，如果现在的状态刚好满足两个串的长度差刚好为 $k$, 则只需要考虑“从左边来”，也就是 $f(a,b-1)$ 这种情况。这是因为，“上面的”那种情况, 也就是 $f(a-1,b)$, 一定是需要多于 $k$ 次增删操作的。如果考虑了从它的转移，也就意味着 $f(a, b-1)$ 需要的操作数应该会更多（最长子串与操作次数是相反的关系，由于二者总长度相等，最长字串更长也就意味着更少的操作次数）。这样一来，$f(a,b)$ 对应的增删操作数实际上也是超过 $k$ 次的。如果从“上面的”转移产生了更少的操作，那么最终的结果当中，我们也可以得到 $a$ 到 $b$ 的转移需要多于 $k$ 次操作的结果。而一旦多于 $k$ 次，我们便不需要关心它具体的数值是多少了。
* 归根结底，上面的算法实际上是基于这样一个事实：在增删次数超过 $k$ 的时候，我们只需要知道它超过了限制这一个信息；反之，我们才需要知道具体的数值。这样一来，我们的填表就变成了：在每一行中只填写 $2k+1$ 个状态 （所有长度差小于 $k$ 的情况），并且在每一行中需要填写的位置是逐渐向右平移的。同时，我们也不难得到边界条件下（到了最后一行还没有平移到最右边，或者是到了最右边却还没填到最后一行），算法的严谨性依然可以得到保证。

## 时空复杂度分析
### 时间复杂度
* 按照上面的填表算法，我们不难得到时间复杂度应该是 $O(nk)$, 同时相应的常数应该是 $2$ 。这样一来，我们需要的总耗时大概是 $10^8$ 量级的，可以接受。
### 空间复杂度
* 我们不难发现，动态规划的过程当中需要两个规模为 $n$ 的滚动数组；同时需要两个存储字符串的数组，长 $n$ 和 $m$ 。考虑到 $n$ 和 $m$ 的数量级相当，我们的空间复杂度可以写成 $O(3n+m)$ = $O(4n)$ = $O(n)$ 。

## 总结
* 在解题的过程中，我遇到的最大困难是如何处理使用 $k$ 优化过后的动态规划。我的疑惑在于利用 $k$ 进行“平移填表”的过程当中，“来自上方的”信息缺失可能会导致算法的错误。
* 然而，我忽略了题目本身的特点，没有意识到其实对于题目在增删次数超过 $k$ 的时候，操作次数的具体数值本身会带来冗余信息，只需要知道是不是超过了 $k$ 次就可以。