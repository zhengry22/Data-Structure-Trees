# Kidd解题报告
> 作者：计26 郑睿阳 2022010849

# 数据结构 & 算法
* 不难发现这道题目的特点非常适合使用线段树进行描述。具体而言, 我们需要实现线段树的三个接口：`Build`, `Insert`, `Query`。这里由于 `Insert` 操作实际上指的就是翻牌操作, 因此程序中将该操作接口命名为 `Flip`。
* 首先上来就遇到了一个问题：线段树的叶节点约定俗成的应该是最基本的单位长线段, 但 $2^{31}$ 的数据量显然不允许我们为每个线段单元都维护一个叶节点! 这时候, 我们想到，似乎只需要将 `Query` 和 `Flip` 操作所查询的端点作为所有的 `Elementary Interval` 即可。这样的话, 只需要存储 $200000*2 + 1$ 个区间作为叶节点即可。本题采取数组的堆式存储存放所有的节点，需要二倍的空间，即 $800002$ 的空间。这个空间复杂度是我们完全可以负担的起的。

### Build接口
* `Build` 接口采取基本的递归建树。本题采取了相对传统的以中位数为分界线进行建树的方法, 在每个叶子节点当中维护了线段的左右端点，懒标记以及当前区间被翻转过的次数。与基本线段树的递归建树方法基本相同。该接口的时间复杂度主要来源于排序，以及为 $n$ 个节点分配空间，时间复杂度由前者决定，为 $O(nlogn)$。

### Flip接口
* `Flip` 接口采取递归方法，与讲义当中所提及的方法大致相同。这里值得一提的是，维护懒标记的思想尽管并没有在讲义当中被显式的提及，但其思想在递归当中有所体现————即如果访问的节点正好完全包含于查找的线段区间就可以直接返回。当然，这里我们需要先更新其节点的懒标记，使其加 $1$。这个方法的复杂度分析可以利用讲义上关于“除了第一步以外至多只存在一次递归”得到为 $O(logn)$。

### Query接口
* `Query` 接口采取递归方法，与讲义当中最大的区别在于懒标记的“不完全下放”————懒标记是我们为了提升程序运行效率所采取的特殊方法。只有在出现当前访问的节点与查询区间满足非包含且交集非空的时候才会对懒标记进行下放。具体操作是，将该节点的懒标记赋值给子节点，并且根据懒标记更新子节点的翻转次数，具体体现为 `Flip += LazySign*length` 。而之所以称之为“不完全”下放，是因为在当前节点完全包含于查询区间的时候不需要下放，直接访问即可，从而达到选择性下放，提升效率的效果。

## 一些坑
* 本题当中，虽然笔者看到了提示当中关于 `long long` 的提示，却还是忽略了懒标记也需要作为 `long long` 参与运算，否则也会出现负数的问题。