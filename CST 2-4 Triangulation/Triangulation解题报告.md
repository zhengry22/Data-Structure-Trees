#Triangulation解题报告
> 作者：计26 郑睿阳 2022010849

## 数据结构
* 本题的算法在题面当中已经有所提到，在报告当中将不展开进一步的说明。这里简要分析一下实现该算法所需要的数据结构。
* 在程序中，实现了 `Sides` 类存储某个点是位于 $x-$单调多边形的上边，下边，还是最左/右端点处。利用 `Vertices` 存储输入的初始节点，`Stack` 作为辅助栈。同时，在笔者提供的算法当中，对所有点进行了按照 $x$ 坐标从小到大的排序，利用 `Sorted` 进行排序后的节点信息的存储。

## 时空复杂度
### 时间复杂度
* 题目当中有提到，算法本身的时间复杂度是 $O(n)$。本算法当中为了维护有序性，则维护了一个排序的数组。排序的时间复杂度是 $O(nlogn)$。值得一提的是，后来笔者发现似乎并不需要维护这个排好序的数组就可以实现相同的算法，只需要维护一个比较用的双指针即可。这也是算法实现在时间复杂度上的一大失误。然而，使用排序数组的确是可以增加代码的可读性。综上，本程序的时间复杂度为 $O(n)$。
### 空间复杂度
* 容易发现，空间复杂度为 $O(n)$。

### 在做题的时候踩的坑
* 输入只保证了顺序性，却不保证顺时针，逆时针以及起始节点的位置。
* 在计算斜率的时候，我第一次用了乘法，并将结果使用 `long long` 数据类型存储。事实上，这道题的数据量会导致存在两条边的斜率差很小，从而无法很好的比较。事实上，选用更高精度的 `float` 可能都无法进行精确的比较。这时候，就应当使用乘法运算进行等价的算式转化，才能算出正确的结果。