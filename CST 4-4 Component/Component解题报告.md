# Component解题报告
> 作者：计26 郑睿阳 2022010849

## 数据结构 & 算法
* 本题主要考察的是对于连通分量信息的高效维护。在这里，使用并查集这一数据结构可以很好的提升在同一连通分量当中进行查找的性能。同时，利用左式堆可以高效的维护前 $k$ 大的节点的信息。
### 并查集
* 并查集的基本实现思路是通过树进行实现。每个连通分支选出一个“代表”作为查找该连通分支其它信息的时候所需要查找的对象。初始状态下，每个点都是一个单独的连通分量，自己为“代表”。在进行 `Union` 操作的时候，首先判断当前所需要 `Union` 的两个点是否处于同一连通分支当中。如果不处于同一连通分支当中，就要实现连通分量的合并。具体的，在查询两个点是否属于同一连通分量的时候需要在 `Union` 接口当中调用 `Find` 接口找到两个连通分量的“代表”。这里值得一提的是，`Find` 的过程中采取递归写法，不仅可以找到代表元，还能将查找的节点的“父亲”指向所谓的代表元，从而减少查找的时间复杂度。
### 左式堆
* 利用左式堆能够快速判断第 $k$ 大的元素是什么。具体操作为，对于每个连通分量，都要维护一个大小不超过 $k$ 的左式堆，入口可以维护在并查集的代表元处。在每次查找的时候都可以首先通过 `Find` 接口找到代表元，并通过其访问左式堆。同时，注意维护左式堆的规模，如果小于 $k$ 可以直接返回找不到。如果恰好等于 $k$ 则只需要返回堆顶的元素即可。
* 在进行 `Union` 的时候，同时也要进行两个连通分量左式堆的合并，然后新的子堆当中的数据便能够反映新的连通分量当中的第 $k$ 大元素信息。因为它若存在，则一定存在于先前两个连通分量的某个堆当中。这里需要注意的是，由于两个连通分量的左式堆规模之和可能超过 $k$，因此在维护的时候需要首先进行部分节点的删除之后再将处理过的堆进行合并。在这里有一个可以降低耗时的方法是先通过类似于归并排序的方法，在两个子堆当中逐个删除更为小的堆顶直到二者规模之和为 $k$。这相比于先合并再删除，无疑在下滤的时候具有更快的速度。

## 复杂度分析
* 需要值得一提的是，本体当中由于节点信息本身不存在数据上的变化，也没有节点的增删，因此为了保持数据的统一性，在一个 `Node` 当中同时维护了并查集和左式堆的两套指针系统。设节点的个数为 $n$, 则总体的时间复杂度无疑应当是 $O(n)$ 的。由于并查集的复杂度分析较为复杂，在经过了一定的学习之后得知其复杂度为 $Θ(α(n))$, 其中 $\alpha$ 是阿克曼函数。同时，左氏堆合并操作的复杂度在分摊意义下应当是 $O(logn_1 + logn_2)$ 的, 其中 $n_1$ 与 $n_2$ 分别是两个子堆的规模。