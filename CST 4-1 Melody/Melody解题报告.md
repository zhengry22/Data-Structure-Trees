# Melody解题报告
> 作者：计26 郑睿阳 2022010849

## 数据结构 & 算法 & 复杂度分析
* 本题为了能够快速查询所有的公共前后缀，构建了 next 表作为数据结构，其作用与讲义上相同，负责提供每个字符串的公共前缀的信息。那么，在获得专辑当中所有乐曲的最长公共前后缀的时候，只需要在 next 表当中对于每首歌曲的前后缀进行统计。
* 需要注意的是，在 `getMaxPresuffix` 这一接口当中，并不能直接去 next 表中获得相应的答案，因为 next 表当中的答案可能超过了字符串长度的一半，违背题意。然而，注意到这种最大前后缀长度超过一般的串都是通过某个循环节一直循环得到的，即可以表示为 “AAA...AA'” 的形式（其中 A' 是 A 的一个前缀子串）。
* 为了证明这一点，我们不妨考虑这种情况下，两个公共前后缀交叠的部分前面的部分。不难看出，这部分就是我们所找的循环节。后面的部分则可以利用前后缀本身的定义，不难发现后缀串应当是“落后于前缀串一个相位”的，但是落后的内容都是相同的，直到最后可能会被截断为一个循环节的前缀。
* 因此可以利用这一特性对于合法的最大前后缀长度直接进行计算。具体只需要通过计算出单个循环节 A 的长度，然后逐次在最初的结果中减去这个长度，直到得到的子串长度小于总长度的一半。具体在代码当中，则是通过:
```
if (maxret > half_length) {
    maxret = maxret-(length - maxret)*((maxret - half_length) / (length - maxret));
}
while ( maxret > half_length) {

    maxret=next[maxret];
}
```
这部分实现的。
* 该部分的 `while` 循环基本可以避免，只是出于严谨的角度采取了这样的写法。其平均分摊意义应该能够达到 $O(1)$ 的地步。
* `getCommonPrefix` 接口当中，需要找到两个 “一阶公共前后缀” 的公共前后缀，即 “二阶公共前后缀”。为了使得求解更为高效，我们知道最终的结果一定要小于二者当中的较短者。考虑到上面的循环节思想，如果我们发现两个串当中的较长者最长的公共前后缀超过了其长度的一半，则可以先求出这个循环节的长度。因为，这时长串的公共前后缀一定是其长度减去循环节长度的整数倍。利用带余除法：`u -= (u-v)/unit;` 即可求出满足这样的长度中不超过短串长度的最大者。如此下去不断往复即可高效的缩小查找范围。
* 该部分的复杂度分析比较困难，需要视具体的数据而定。在分摊意义下来看，无疑可以分成 next[length] 是否小于 `length >> 1` 两张情况进行讨论。若不大于，则可以直接跳到 length = next[j]的部分，实现减半；反之，则可以使用 $O(1)$ 计算的比较法进行跳转。二者由于都是对长串进行减半，因此时间复杂度应该是 $O(logn)$。
* 同时，由于题目的空间消耗主要来源于 next 表的构建，因此空间复杂度是 $O(n)$。

