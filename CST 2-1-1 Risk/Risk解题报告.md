#Risk解题报告
> 作者：计26 郑睿阳 2022010849

## 数据结构
* 由于题目已经提示我们使用 `Queap` 这一数据结构实现程序，因此我们的算法是基于 `Queap` 设计的。然而，在实现 `Queap` 之前，我们需要明白这道题为什么能够使用 `Queap` 实现。
* 题目实际上可以进行如下的抽象：给定项数均为 $n$ 的非负整数序列 $\left\{x_n\right\}$ 以及正整数序列 $\left\{m_n\right\}$, 如何快速的构造序列 $\left\{a_n\right\}$, 其中 $\left\{a_i\right\}$ = $max\left\{x_{i-m_i}, x_{i-m_i+1},  ...... , x_{i-1}\right\}$。考虑到序列 $\left\{i-m_i\right\}$ 与 $\left\{i-1\right\}$ 都是单调不下降队列，我们便发现上面 $\left\{x_{i-m_i}, x_{i-m_i+1},  ...... , x_{i-1}\right\}$ 构成的序列在每个状态下“单调右移”的特性，进而可以把这一序列抽象成一个队列, 我们执行的操作是每次 $i$ 增加 $1$, 就 `enqueue` $1$ 个元素，并将前面的若干个元素进行 `dequeue`, 从而使队首元素的秩为 $i-m_i$。我们该队列为 $diagnose$ (确诊病例数量)。
* 而 `Queap` 的数据结构需要在这个基础上实现分摊 $O(1)$ 的 `getmax()` 接口。这里单调队列的设计可以按照如下逻辑实现：
> * 在上述的 $diagnose$ 队列之余，我们维护 `Queap` 类型的数据结构 $queue$ (由于单调队列也是队列，所以给它起了个有些迷惑的名字)。其中，$queue$ 存储的元素数据类型是一个结构体 `queue_elem`，它由 `index` 和 `num` 字段组成，二者分别表示 $diagnose$ 当中某个元素在 $diagnose$ 底层数组当中的秩，以及它的实际大小。

> * 对于 $queue$ 进行如下操作：每次 `Enqueue` 的时候需要逐个比较入队元素和队尾 `num` 的大小。如果 $queue$ 队尾的 `num` 比入队元素小，就用入队元素代替之，同时队列的规模需要缩小 $1$ 。多次执行上述操作，直至 不增。需要注意的是，这里我们比较的标准是入队元素“小于”队尾，而非小于等于队尾。具体原因会在下面进行说明。

> * 然后在 `Dequeue` 的时候，由于我们已经知道了第 $i$ 天当中所需要考察的范围为 $[x_{i-m_i}, x_{i-1}]$, 因此我们只需要从 $queue$ 的头上不断 `Dequeue` 掉所有 `index` 小于这个范围的所有元素。

> * 通过上述先执行 `Enqueue`, 后执行 `Dequeue` 的操作，我们得到了第 $i$ 天的 $queue$ 的状态。 

* 通过以上的逻辑，我们能够保证，第 $i$ 天的 $queue$ 的队首一定是上述区间内最大的元素。我们不妨进行一个简短的归纳证明。注意，这个证明是不依赖于这道题目的，即对于任意的队列 $Q$, 与它按照上述关系关联的 `Queap` 类型数据结构 $queap$ 都会有相关特性。在这里，为了简化说明，我们在 $Q$ 与 $Queap$ 当中的元素都取一般的实数，而不是我们上面所定义的 `queue_elem`。

> * 在初始状态下，$queue$ 为空。我们首先建立初始状态，向队列 $Q$ 中 `Enqueue` 入第一个元素。相应的，也会向 $queap$ 当中 `Enqueue` 入该元素。这个操作是平凡的，此时 $queap$ 显然满足队首元素是 $Q$ 中最大值。

> * 归纳：我们接下来证明，假设在状态 $A$ 下待证命题成立，则在该状态下进行一次 `Enqueue` 或 `Dequeue` （这里我们不妨假设 $A$ 状态下 $Q$ 是非空的）达到了状态 $A'$ 后，`queap` 队首依旧是 $A'$ 状态下最大的元素。

> * 首先考察 `Enqueue` 操作：新 `Enqueue` 的元素 $n$ 可以分为 $3$ 种情况进行讨论：该元素大于，等于或小于 $A$ 状态下 $Q$ 中的最大者。
> * 若大于：则 $n$ 入 $queap$ 后会逐渐将所有 $queap$ 中元素取代，最后留下一个长度为 $1$ 的 $queap$, 显然此时 $queap$ 队首是 $Q$ 中最大者。
> * 若等于：情况和上面相似，只是 $queap$ 的长度此时并不为 $1$。此时的 $queap$ 内含有的所有元素应该都是相同的, 也自然满足待证命题。
> * 若小于：则 $n$ 不会交换到 $queap$ 队首就会停下来。此时，$queap$ 中 $A'$ 状态下队首元素和 $A$ 状态下队首元素相同，显然满足待证命题。

> * 再考察 `Dequeue` 操作：假设 $Q$ 中现在有元素 $a_0, a_1, ..., a_n$, 相应的 $queap$ 中有元素 $b_0, b_1, ..., b_m$, 那么进行一次 `Dequeue` 操作之后，只有两种情况：`Dequeue` 的元素是 $Q$ 中最大者，或不是最大者。由于之前的 `queap` 底层数据类型与这里不同，我们进行如下规定：如果 `Dequeue` 的元素在 $queap$ 队首，则 $queap$ 也要 `Dequeue`。反之则不进行操作。下面证明，在这种规定下，`Enqueue` 操作依旧维持 $queap$ 队首元素的最大性。

> * 如果 `Dequeue` 的元素在 $A$ 状态下最大，则 `Dequeue` 操作后，队首的元素 $a_1$ 必然是剩下的最大者, 原因如下: 在这之前 $a_1$ 必然进行了一次 `Enqueue` 操作，并且在 $queap$ 当中成功的保存了下来。注意，因为 $a_0$ `Dequeue` 后队首是 $a_1$, 因此必然不存在在$a_0$ 后， $a_1$ 前入队的比 $a_1$ 大的元素。反之，$a_1$ 就不在 $queap$ 的队首了。同时在 $a_1$ 后入队的元素不可能有大于 $a_1$ 的，否则 $a_1$ 就会被交换掉，从而不存在于 $A$ 状态的 $queap$ 当中。这里我们也可以回答为什么这里我们比较的标准是入队元素“小于”队尾，而非小于等于队尾了——因为队列当中可能存在多个相同的最大元素，但我们不希望将其中的一个最大元素 $Dequeue$ 后也将剩余与它相同的最大元素的信息丢失。

> * 如果 `Dequeue` 的元素在 $A$ 的状态下不是最大的，那么此时它本来就不在 $queap$ 的队首。状态 $A'$ 下的 $queap$ 队首也必定是最大元素。

* 综上，我们完成了证明。

## 算法
* 具体采用 `Queap` 实现的算法在上面的数据结构当中已经介绍的较为详细了。然而，在使用 `Queap` 之外，本题的另一难点在于大量的查询操作。稍有不慎便会带来极大的时间复杂度。

* 一个自然的想法是，我们需要将每一天的风险值 $r_i$ 进行排序，然后查找。本来笔者想使用传统的快速排序与二分查找的算法进行操作。然而后来笔者通过与同学的讨论，注意到这题 $x_i$ 的范围并不大，因此完全可以使用时间复杂度为 $O(n)$ 的桶排序。然后，我们可以再使用 $O(n)$ 的时间来维护一个前缀和的数组: $s_k = \sum_{i=0}^{k} bucket_i$ 。借助这个数组，我们完全可以使用 $O(1)$ 的时间进行低风险，中风险天数的查找。需要注意的是，低风险，中风险可能会有超过 $2*10^6$ 的可能。如果只有中风险超过该值，则只需要将中风险值下放到 $2*10^6 + 1$；而低风险也是同理的。这么做可以保证开闭区间的正确性，也保证了如果二者同时超过临界值，则中风险天数会等于 $0$。

## 时空复杂度分析
### 时间复杂度
* 对于数据规模为 $n$ 的数据，使用 `queap` 进行 $n$ 次查找：所有入 `queap` 的元素个数应该不超过 $n$。运用分摊的方法考察每个元素在 `queap` 当中的表现：`Enqueue` 操作可以理解为逐个比较队中元素，如果队尾元素小于 `Enqueue` 的元素就让元素在队尾进行弹出（尾 `Dequeue`）;这样一来，我们可以将 `queap` 的 `Enqueue` 操作拆分为若干次尾 `Dequeue` 和一次真正意义上 $O(1)$ 的 `Enqueue` 。这样一来，对于每个元素而言，它无非会经过这样的操作：一次 `Dequeue` 或一次尾 `Dequeue`，以及一次 `Enqueue`, 均为 $O(1)$。同时，每天还会进行一次 `getmax`。 因此，维护 `queap` 的时间复杂度应当是 $O(n)$ 的。
* 本算法使用了桶排序，假设数据范围为 $x$, 则桶排序，以及维护前缀和序列所需要的时间复杂度应当是 $O(x)$ 的。最后进行运算操作时间为 $O(1)$。
* 综上，时间复杂度是 $O(n+x)$。
### 空间复杂度
* 不难得到，空间复杂度是 $O(n+x)$。
