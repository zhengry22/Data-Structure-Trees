#LAB1解题报告
> 作者：计26 郑睿阳 2022010849

下面是 LAB1 当中10份测例的错误类型及原因，以及排查原因的思路。
> * 01: 
**错误类型**：Runtime Error
**错误原因**：没有考虑到调用 `play(rank)` 函数的时候 `rank` 可能为负数的情形。为了触发这一点，考虑 `play` 函数当中会在触发连消时进行连续递归，只需要考虑在 `rank = 0` 处插入珠子触发连消的情况即可。
**测例构造**：在 `play` 函数的调用当中，我注意到连消会直接触发多次递归，但是在 `rank` 等于0时会触发不合法的递归 `rank(0-1)` ，因此根据这一点构造数据，使得触发消除后序列为空即可。

> * 02: 
**错误类型**：Runtime Error
**错误原因**：没有考虑到在串为空串的时候可以 `play(0)` 。这时候，访问 `rank = 0` 的位置会造成越界访问。
**测例构造**：`play` 函数调用会直接访问串秩 `rank` 的元素, 容易想到在串为空串的时候会出现越界访问的情况。只需要让某一时刻为空串即可。

> * 03: 
**错误类型**：Time Limit Exceeded
**错误原因**：删除，插入操作都是对 `string` 类对象直接进行操作，没有考虑到 `string` 类对象的插入操作实际上是 $O(n)$ 的。这样一来，只要构造接近满数据的样例（笔者使用的样例甚至没有达到满数据）,就会暴露出十分严重的时间问题。
**测例构造**：我们希望每次插入都能够正好激发 $O(n)$ 时间的插入操作，所以每次都在 `rank = 0` 的位置插入字母即可。这样一来，设初始长度为 $n$, 考虑插入数量为满数据，则从数量级的角度上来说，笔者构造的测例达到了 $10^{11}$ 量级。

> * 04: 
**错误类型**：Wrong Answer
**错误原因**：在考虑消除区间的时候，左侧区间的位置错误。`string` 类的 `erase` 函数需要传入的参数是左侧开始消除的位置，而这份代码中 `play` 函数当中所计算出来的左侧位置实际上是正确的位置再左移一个位置。
**测例构造**：只需要触发一次消除，就可以发现序列中消除子序列左侧的一个元素也被消除了，这本是不该出现的。

> * 05： 
**错误类型**：Wrong Answer
**错误原因**：使用 `cin` 进行输入，输入不够鲁棒，无法正确处理初始序列为空串的情况。
**测例构造**：题面当中已经有关于输入鲁棒性的提示。根据这一点构造 `cin` 无法处理的样例即可，也就是初始情况为空串的样例。

> * 06： 
**错误类型**：Wrong Answer
**错误原因**：使用分块数组进行序列存储的时候，没有即时在某分块数组的长度超过上限时进行重构。这样一来，某些超过单个分块数组长度上界，且可能触发连消的输入可能存在问题。
**测例构造**：尝试构造初始长度超过一个单个分块数组的序列，并不断在头部加入元素，且达到最后插入一个珠子就可以引发大规模连消的效果。由于分块数组在每次插入之后并不会重组，因此会出现第一个分块数组的规模很大的情况。因此，触发连消的时候，由于程序实际上采用了默认每个分块数组长度不会超过上界的界定消除序列的方法，因此过于长的数组会有相当一部分后缀无法参与消除，从而导致正确输出结果应当只有几个字符的输入产生十分冗长的输出。

> * 07： 
**错误类型**：Wrong Answer
**错误原因**：未考虑大规模连消后，序列中的字符在不相邻的分块数组当中的情况。在代码当中体现为计算消除区间的时候使用 `if` 语句进行数组间的 `rank` 转换而不是 `while`。
**测例构造**：与 06 类似，构造大规模的初始序列，并尝试通过一次插入触发大规模连消。需要注意的是，连消一定需要保证在消除后的序列中存在两个相同字符，它们虽然在珠子序列中相邻，但所处的分块数组却相隔了很多个，从而无法在下一次插入相同字符的时候触发再次连消。这样一来，在适当插入相同字符后会得到一个明显错误的，包含连续三个相同字符的输出序列。

> * 08： 
**错误类型**：Wrong Answer
**错误原因**：在计算需要消除的区间时，没有考虑连消的情况。在代码当中体现为计算消除区间时没有将相关操作放在一个 `while` 循环当中。
**测例构造**：尝试触发连续消除即可。

> * 09： 
**错误类型**：Runtime Error
**错误原因**：没有正确处理消除区间在一个分块数组内的情况，在代码当中具体体现为用多块数组的处理方式处理单个分块数组的消除，从而会在从新将分块数组组装回序列的时候诱发越界访问的问题。
**测例构造**：尝试触发单个分块数组内的消除即可。

> * 10： 
**错误类型**：Wrong Answer
**错误原因**：消除区间处理出现问题。在代码当中具体体现为直接将最左边发生消除现象的分块数组的长度置零，忽略了该数组可能只有部分进行消除的情况，即置零循环从 `l.first` 而非 `l.first + 1` 开始。
**测例构造**：尝试诱发一次并不会将最左侧开始进行消除的分块数组完全消除的连消，再尝试进行后续的插入操作即可。