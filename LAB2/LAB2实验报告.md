# LAB2实验报告
> 作者：计26 郑睿阳 2022010849

## 不同哈希策略的实现
* 坏策略：$Hash(s) = \sum_{i=0}^{strlen(s)-1}s[i]$.
* 好策略：$Hash(s) = \sum_{i=0}^{strlen(s)-1}3^is[i]$.
* 双平方试探：代码使用装饰器模式，除上一轮试探结果外需记录上次跳转的步数 `previous_step`, 这一步跳转的步数 `next_step`, 以及跳转方向 `sign`。利用这些信息很容易得出下一步的位置。
* 公共溢出区试探：代码实现了继承 `hash_entry` 类的 `overflow_area` 类作为公共溢出区的容器，添加 `my_next` 字段实现。若 `Table` 已被占用则将 `overflow_area` 数值对象 `Overflow` 的末尾加入元素。同时维护 `enter` 表作为每个哈希值的公共溢出区入口以及 `previous` 表作为每个哈希值对应搜索链的末尾元素。每次查询循链即可, 达到链表的效果。

## 进行测试
* 数据生成器 `random.cpp` 接受三个命令行参数，分别是 插入， 查询， 查询命中率（不是概率，但与命中率正相关）。
* 三组数据构造的特点分别满足：
* 插入数量与查询数量相差较大，且全部不命中：`./random 10000 50000 1`
* 插入数量与查询数量相当，且几乎全部命中：`./random 25000 25000 1000`
* 插入数量与查询数量相差较大，且几乎全部命中：`./random 10000 50000 1000`

## 分析结果
* 好哈希在使用线性试探时的用时大概是坏哈希的 $1/50$, 在使用双平方试探大概是 $1/3$ 到 $1/2$, 在使用公共溢出区时无明显区别。坏哈希的不均匀性导致了较大的碰撞概率，在查询操作较多，尤其是线性查询时耗时显然较为严重。
* 在哈希相同时，线性试探的时间大概是双平方试探的 $50$ 倍, 原因如上所述。
* 公共溢出区策略更占优势,但其耗费大量空间。试探链在空间限制严格时更为适合。若查询操作远多于插入操作,试探链将具有与公共溢出区相近的性能。
* 可能造成大量的冲突和不均匀分布。
* 类比`vector`并实现哈希去碎片化的函数,缩容时合理为原先的键分配空间,做到不重不漏。

## 对代码框架进行的更改
* 为判断虚函数 `collision_strategy` 的类型，人为添加了 `probe` 标志作为标识，不同的派生类 `probe` 标志不同。注意，没有改动原有类的代码。
* 修改了公共溢出区时的代码调用逻辑（这是题干中明确提出可以进行的操作）。