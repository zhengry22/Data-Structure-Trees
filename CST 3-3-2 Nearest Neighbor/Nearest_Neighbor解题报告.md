# Nearest Neighbor解题报告
> 作者：计26 郑睿阳 2022010849

## 数据结构 & 算法
* 事实上，本题是人工智能领域十分重要的 $k-$近邻问题。使用 `kd-tree` 这种数据结构很好的符合其题目特点。由于 `kd-tree` 本身不涉及到节点的增删操作与节点之间拓扑结构的改变, 因此我们依旧可以使用堆式存储，达到避免使用指针导致占用过多空间的效果。其所消耗的空间复杂度为 $O(n)$, 常系数大概为 $2$。
* 这道题目本身与我们熟知的 `kd-tree` 别无二致。为了拆分问题，依旧将问题接口化，抽象为 `Build` 建树接口，以及 `LeastDistSquare` 接口，即求出某给定点距离树上所有点中最短者的平方。

### Build接口
* `Build` 接口采取递归实现，具体方案如下：每次选取一个维度，在该维度的意义下选取中位数。这里中位数的选取可以采用经典的 `partition` 方法，与快速排序具体的实现原理是相近的。然后将小于中位数，大于中位数的点放置到两边(底层实际上是维护了一个所有点的数组，然后对于数组的左半边和右半边分别递归建树)。每次建树选取中位数的维度都需要以轮换的方式更换。
* 由于每次 `Build` 都需要查询中位数，其时间复杂度为 $O(n)$ (平均意义而言，实际最坏可能会达到$O(n^2)$)，因此可以根据主定理列出递推式：$$T(n) = 2T(n/2) + O(n)$$ 最终解得$T(n)=O(nlogn)$。

### LeastDistSquare接口（以下简称LDS）
* `LDS` 接口采取递归实现。具体方案如下：每次从根开始，判断节点与根节点在给定维度上的大小关系。若小于等于则进入左子树进行递归，反之进入右子树。这里有一个降低时间复杂度的技巧：如果不加以区分的对两边的树均进行递归查询，其耗时将是不可忍受的。递归完左子树后，此时我们已经获得了该节点和左子树中所有节点直接距离平方的最小者。此时可以优先判断一下查询节点和右侧子树之间的最小可能距离的平方（也就是和根节点在其对应维度上的距离的平方，类似于以查询点为圆心，左数递归结果的平方根为半径画圆）是否已经超过了左边的结果。如果超过就不必再深入递归。如果一开始访问右子树，也是同理。
* 该接口在 $k$ 维度的意义下进行操作，时间复杂度为 $O(n^{1-1/k})$。如果在算上输出所需要耗费的时间，可以写为 $O(n^{1-1/k} + r)$ 。

## 做题时遇到的一些困难
* 本题遇到了多次超时问题。第一次超时问题在于未能正确的实现上述 `LDS` 接口当中所提到的剪枝操作。而后面的超时则是无从下手。考虑到算法实现的时间复杂度都是没有问题的，因此打算从计算机系统概论的角度进行性能优化。先后对于输入的方式，数据存储信息的冗余进行了优化，有所收效但并不彻底。后面，我想到由于本题采取的所有算法均为递归，过多的递归操作可能会导致压栈过多从而带来较大的时间损耗。因此我在 `LDS` 接口当中将返回值改为一个全局变量的存储，时间陡降。看来做好算法题不仅需要算法基础，还需要对计算机系统的工作方式有深入的理解。



