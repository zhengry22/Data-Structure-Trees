# Feature 解题报告
> 作者：计26 郑睿阳 2022010849

## 写在前面
* 由于树的接口相对统一，且程序调试相对苦难，因此本次 PA 的三道题目均采取了面向对象的程序风格。同时，由于本人并非信息竞赛生，对于许多技巧并不熟悉，因此只是按部就班的参考讲义实现了接口。500 行的代码是令人望而却步的工程量，但使用面向对象的编程风格对于程序的调试确实带来了很大的便利。考虑到在代码的编写当中，调试所需要耗费的时间远比正常编写代码要长，因此我依旧认为这是很不错的事情。

## 数据结构 & 算法
* 本题作为交互题，提供了四个接口。我们需要将这些接口一一抽象为 `Splay` 树的接口进行操作。本题与 PA3 的另外两道题有所区别————这次涉及到了树拓扑结构的变化，但不涉及节点个数的变化。因此依然可以使用 $O(n)$ 的节点进行存储。
* 在每个节点当中存储了许多信息，包括：左右孩子的指针，父亲的指针，以其为根的子树规模与正节点数量，$w$ 值及其绝对值，$x$ 值，以该节点为根的子树的线性回归值。

### init 接口
* 可以抽象为是 `Splay` 树的 `Build` 操作。由于 `Splay` 树继承自 `BBST`, 故在建树的时候可以参考 `BBST` 的方式。由于树的中序遍历需要满足单调性，故我们应当首先进行排序，再进行经典的递归建树。其时间复杂度由排序算法决定，整体为 $O(nlogn)$。这里值得一提的是，我们实现的 `Splay` 树是按照 `w` 值的绝对值从小到大进行的排序，然而接口的规定操作当中还存在按照 `w` 值本身的大小进行搜索的操作。一个相对自然一点的想法是维护两棵树，但这样一来进行操作的成本未免过高。笔者在程序中使考虑到绝对值的大小可以部分的对应到实际大小————绝对值越大的正数越大，绝对值越大的负数越小，因此可以利用这一特性维护每个节点左右孩子所代表的子树当中所有节点，以及非负节点的个数，从而以此为信息与绝对值的信息来维护 `w` 本身的全序关系而非其绝对值的全序关系。这样就可以避免构建两棵树。

### modify_weight 接口
* `Splay` 树乃至 `BST` 当中都没有“修改节点”的操作。不过很容易想到对一个节点的修改就等价于先将其删掉，再插入新的节点。因此该接口调用了名为 `RemoveAndInsert` 的函数。具体表现为先将指定的节点通过 `Splay` 操作（该操作基本参考了讲义的写法，在这里不再赘述）伸展至顶端，在顶端直接进行删除，再在顶端进行插入。具体的删除过程可以表现为删除根节点后, 使用预先编写好的 `Search_kth_abs` 接口找到绝对值最小的右子树节点 `Splay` 到顶端为根。之后再进行一次插入即可。因此，该接口主要耗费的时间复杂度是两次 `Splay` 的时间，也就是 $2*O(logn)$。

### modify_value 接口
* 首先调用搜索第 $k$ 大值（注意不是绝对值）的接口进行搜索，具体的实现方法在建树操作当中有所提及————关键在于对每个节点不仅维护以其为根的子树规模，还要维护子树中非负数节点的数量。根据这些信息很容易判断搜索的值是不是负数。然后，修改 `x`, 通过 `Splay` 操作将节点旋转至顶端即可。时间复杂度依然为 $O(logn)$。

### calculate 接口
* 本题的关键，也是最能体现 `Splay` 树操作特点的接口。计算前 $k$ 大的绝对值的和只需通过 `Search_kth_abs` 将第 $k+1$ 大的节点转到根部，访问右子树的根节点的总和即可（如果是前 $n$ 大就直接返回根节点信息）。时间为 $O(logn)$。